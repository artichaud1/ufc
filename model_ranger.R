library(stringr)
library(dplyr)
library(lubridate)
library(recipes)
library(rsample)
library(purrr)
library(magrittr)
library(ranger)
library(ggplot2)
library(ggthemes)
library(foreach)

source('featurize.R')

raw_df <- readRDS('fights_model_df.RDS')

# Exclude 1st fights from modeling data
except_1st_fights_df <- raw_df %>% filter(!is.na(Prev_Cume_Mins_1), !is.na(Prev_Cume_Mins_2))

# Now any remaining NA's with zeros
no_NAs_df <- except_1st_fights_df %>% replace(is.na(.), 0)

full_df <- 
  no_NAs_df %>%
  select(
    target,
    Weight.class,
    Date,
    intersect(starts_with('Prev_Cume'), contains('_PM')),
    intersect(starts_with('Prev_Cume'), contains('_Ratio'))
  ) %>%
  replace(is.na(.), 0) %>%
  mutate(
    target = factor(target),
    gender = factor(ifelse(str_detect(Weight.class, 'Women'), 'female', 'male')),
    Weight.class = factor(str_trim(str_replace(Weight.class, "Women's", '')))
  ) 

full_features_df <- 
  full_df %>%
  featurize_fight_advantages() %>%
  select(target,
         Date,
         starts_with('Adv'), 
         gender,
         starts_with('Weight.class'))

train_df <- full_features_df %>% filter(year(Date) < 2017) %>% arrange(Date) %>% select(-Date)
test_df <- full_features_df %>% filter(year(Date) >= 2017) %>% arrange(Date) %>% select(-Date)

rec <- 
  recipe(train_df) %>%
  add_role(target, new_role = 'outcome') %>%
  add_role(-target, new_role = 'predictor') %>%
  step_novel(all_nominal(), -target) %>%
  step_dummy(all_nominal(), -target, one_hot = TRUE) %>%
  step_zv(all_predictors())

train_samples_df <- 
  train_df %>%
  rolling_origin(initial = 3000, assess = 500, cumulative = FALSE, skip = 500)

train_samples_df$recipes <- map(train_samples_df$splits, 
                                prepper, 
                                recipe = rec,
                                retain = TRUE,
                                verbose = FALSE)


# Return specific model predictions using specified training params.
train_predict_ranger <- function(recipe, split, params, target){
  
  model <- ranger(data = as.data.frame(juice(recipe)), 
                  dependent.variable.name = target,
                  num.trees = 50,
                  write.forest = TRUE,
                  probability = TRUE,
                  min.node.size = params$min.node.size,
                  mtry = params$mtry)
  
  eval_df <- bake(recipe, newdata = assessment(split))
  preds <- predict(model, eval_df, type = 'response')$predictions
  
  bind_cols(target = as.numeric(as.character(eval_df[['target']])), predicted = preds[, '1'])
}

# For a grid of params, return list of model predictions.
grid_predict <- function(recipe, split, param_grid, target, train_predict){
  foreach(params = param_grid) %do% {
    train_predict(recipe, split, params, target)
  }
}

param_grid <- cross(list(mtry = c(10,5), min.node.size=c(10,50)))

# df is expected to have columns `recipes` and `splits`
# param_gris is expected to be a list of list (generated by purrr::cross for example)
# train_predict is a function that takes parameters recipe, split, params and target, and returns
# model predictions using specified params.
# metrics is a list of metric functions, taking predictions and target values as parameters.
grid_search <- function(df, target, param_grid, train_predict, metrics){
  df %>%
    mutate(
      params = list(param_grid),
      pred = pmap(
        list(recipes, splits, params),
        tune,
        train_predict = train_predict_ranger,
        target = target
      )
    ) %>%
  unnest(params, pred) tmp %$%
  bind_cols(
    invoke_map(
      metrics,
      list(list(tmp$pred$predicted, tmp$pred$target))
    )
  ) %>%
  bind_cols(
    transpose(.$params) %>% map(unlist) %>% as_data_frame()
  ) %>% 
  select(-params)
}


grid_search(train_samples_df, param_grid, train_predict_ranger)
  


tuning_results <- 
  train_samples_df %>%
  group_by(
    mtry = map_dbl(params, 'mtry'),
    min.node.size = map_dbl(params, 'min.node.size')
  ) %>%
  summarize(
    accuracy = mean(accuracy)
  )

ggplot(data = tuning_results) + 
  geom_point(aes(x = min.node.size, y = accuracy, col = factor(mtry), group = factor(mtry))) + 
  geom_line(aes(x = min.node.size, y = accuracy, col = factor(mtry), group = factor(mtry))) + 
  theme_bw()

  