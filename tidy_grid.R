library(dplyr)
library(purrr)


train_predict <- function(recipe, split, params, target, train_func, predict_func){
  
  model <- train_func(juice(recipe) %>% as.data.frame, target, params)
  
  eval_df <- bake(recipe, newdata = assessment(split))
  preds <- predict_func(model, eval_df)
  
  bind_cols(target = as.numeric(as.character(eval_df[[target]])), predicted = preds)
  
}

# For a grid of params, return list of model predictions.
grid_predict <- function(recipe, split, param_grid, target, train_func, predict_func){
  foreach(params = param_grid) %do% {
    train_predict(recipe, split, params, target, train_func, predict_func)
  }
}


# train_data is expected to have columns `recipes` and `splits`
# param_grid is expected to be a list of list (generated by purrr::cross for example)
# train_func is your model training function. Must accept parameters data.frame, target and params.
# predict_func is your model predict function. Must accept parameters model and data.frame.
# metrics is a list of metric functions, taking predictions and target values as parameters.
# ... arguments to metrics functions (e.g. threshold)
grid_search <- function(train_data, target, param_grid, train_func, predict_func, metrics, ...){
  
  if(length(names(metrics)) < length(metrics)){
    stop('All elements in metrics parameter must be named')
  }
  
  train_data %>%
    mutate(
      params = list(param_grid),
      pred = pmap(
        list(recipes, splits, params),
        grid_predict,
        target = target,
        train_func = train_func,
        predict_func = predict_func
      )
    ) %>%
    unnest(params, pred) %$%
    bind_cols(
      .,
      map_dfr(
        pred,
        function(pred){
          invoke_map_dfc(
            metrics,
            list(list(pred$predicted, pred$target, ...))
          )
        }
      )
    ) %>%
    bind_cols(
      transpose(.$params) %>% map(unlist) %>% as_data_frame()
    ) %>% 
    select(-params)
}